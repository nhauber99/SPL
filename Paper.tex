\documentclass[conference]{IEEEtran}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{svg}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Managing variability in software systems}

\author{\IEEEauthorblockN{Niklas Hauber}
\IEEEauthorblockA{\textit{Johannes Kepler University} \\
Linz, Austria \\
niklas.hauber@solentia.at}
\and
\IEEEauthorblockN{Jonas Reichhardt}
\IEEEauthorblockA{\textit{Johannes Kepler University} \\
Linz, Austria\\
j.reichhardt@tig.at}
}
\maketitle

\begin{abstract}
With the growing complexity of software systems, variability of said has become an increasing problem and managing it is thus a crucial part of the present-day software engineering process. It is particularly vital if either many product versions make use of an existing architecture over a long period of time or if a variety of software systems share a common code base. The focus of this paper is to provide an overview of how variation in software systems is caused, how it influences the development process and how it can be dealt with.
\end{abstract}

\section{Introduction}
Building software systems which can adopt to changes from outside as well as within said system represents a vital goal to build software systems that last. When these goals are achieved the effort and therefore costs are reduced for maintenance, but also for further improvements and extension. \\

Therefore, a lot of companies design their software such as numerous variants exists, which allows customization to meet the requirements which are laid out by customers and stakeholders. One of the most used practices to achieve a variant-rich software system is software product line engineering (SPLE) which uses concept, processes, modeling techniques for features, functions, design patters and respective tools to support the process.\cite{b5}\\

If one wants to design a system which is prepared for change, the focus should lie on developing components which have loose coupling and strong cohesion. Thus a module solves one simple task and is as independent as it can be. This leads to the least amount of unwanted side effects in other modules if one module is confronted with unpredicted variability.\\

We will try to provide a basic introduction of how variability is managed in software systems by collecting information from other studies which describe the key aspects of this vast field of research. In the first section we are providing some base knowledge acquired previous studies. After that we will lay out how one can identify the various sources of variability in software systems. Then we will bring up techniques and processes which have the purpose of modeling the variation in a software system. Last but not least we will discuss some of the big tasks which have to be addressed and conclude the topic.

\section{Background and related work}
As variability has always been a problem in software systems, a lot of research and developement have been put into this topic, in order to advance the subject of managing variability.\\

Managing variability is certainly not a trivial task, as requirements differ vastly when looking at different industries. Therefore several strategies exist for engineering variant-rich systems, each with its own advantages and disadvantages. \cite{b5}

The main direction existing research has progressed is how to model variability \cite{b4}, by attempting to formulate principles of building and maintaining said models. Often by analyzing various existing papers on the topic. Two approaches of how to model variability have gained the most importance: feature modeling and decision modeling. \\

The origin of feature modeling is the feature domain analysis method (FODA), which tries to outline common and variable parts of a system. A lot of work as since been done on this, extending the original notation.\cite{b6}\\

Decision modeling has its earliest documented approach in the synthesis method. \cite{b6} This defines it as \textit{a set of decisions that are adequate to distinguish among the members of an application engineering product family and to guide adaptation of application
	engineering work products}. [7 p. 104]\\

All in all there exists various literature on the different scopes variability management encompasses and we try to capture the main points of several of them in this paper.

\section{Origin of variability}
Variability is the ability of software to be changed for specific context. That encompasses extension, customization and reconfiguration. It thus defines the parts of the software that remain variable and are not fully specified yet. \cite{b4}\\\\
There are two main cases where one needs to capture different alternatives within an architecture:\\
\begin{enumerate}
	\item At the time of design there may exist various alternatives and if a decision cannot be made yet because of lack of information, it will be deferred. Therefore one must design the system to be able to handle all viable alternatives.\\
	\item There already exists a product line which contains several different alternatives for given parts of the software, which can be chosen depending on the needs of each individual customer.\\
\end{enumerate}
While these situations differ greatly in reality, in the context of variability management they are really the same. That is, before a decision is made on which alternative is going to be chosen, one does not know the outcome and needs to be able to handle all possible ones.\cite{b3}\\

There are also several reasons why such variations have to exist in the first place \cite{b3}:
\begin{enumerate}
	\item \textit{Variation in function.} Not every product supports the same functions. Take as example a modern smartphone, some might support fingerprint authentication, some might support facial recognition authentication and some support neither.\\
	\item \textit{Variation in data.} Products might vary in the definitions of data structures. For example a software managing planned repairs of industrial machines might need store additional information for some companies like an SAP id in case these planned repairs are also concurrently managed in SAP, while some other companies might not need that information.\\
	\item \textit{Variation in technology.} The technology different products run on may vary. Some software systems for example need to run on Linux while others need to support Windows. Or for some a simple MySQL database might suffice while others need the SQL Server Enterprise edition because the amount of data might vary significantly.\\
	\item \textit{Variation in environment.} The environment software exists in might vary. Meaning also the way in which it interacts with its environment. \\
\end{enumerate}
These, at least, are the four most common origins of variation. Of course some more do exist, but these are beyond the scope of this document.\\
\section{Variability modeling}
As mentioned, there are two main approaches for managing variability. For each of which we will discuss the advantages and disadvantages and create a broad overview over the different modeling approaches.\\\\\\
\textbf{Feature modeling}\\
Features in the context of feature modeling are behaviours, characteristics or functionalities which are observable by the user of the software system. They can be used to define commonalities and differences between systems and their variants, as well as determine mandatory, optional or alternative aspects of them\cite{b8}. A broadly used approach of displaying features and their relations is a hierarchically structured diagram which is called a features diagram.\\

A big advantage of feature models, especially in the shape of feature diagrams, is a possible communication enhancement between stakeholders. This can be achieved by providing an overview of all functionalities which are offered to the user by the system. Due to the nature of the structure of the model and due to the fact that it displays if and which planned features are already provided by another system or system family, this may improve the cost and time estimation for developing the software system. \\

The essence of feature modeling is the splitting of features into distinct objects which have a certain relation to each other. There are several types of features mentioned in \cite{b8}, named \textit{mandatory, optional and alternative features}. Generally speaking common attributes of systems are described by mandatory features, while alternative or optional features define the variability in feature models.\cite{b9}\\

If a feature is mandatory it has to be selected if its parent feature is selected, the type of the parent feature does not matter. A optional feature can be selected freely but there may be constraints from composition rules (e.g. a feature can only be choosen as part of a feature sets). Alternative features are can be pictured as a choice box, exactly \textit{one} item must be chosen from a feature set.\\

This is the approach which is used in the original FODA paper, which was extended with the introduction of cardinalities for alternative features.\cite{b10} This expansion grants the ability to create minimum and maximum constraints for choosing alternative features from a feature set, which helps with creating complex models.

\begin{figure}[h!]
	\includegraphics[width=\columnwidth]{feature_model}
	\caption{Simplified feature model of a car}
\end{figure}
In Fig. 1, one can see a small feature diagram of a car, it consists of one root node, that describes the domain we are modeling, in this case the car. The previous elaborated mandatory features are the engine and seats. Furthermore there is the option to install a cruise control and the option for a turbocharger. These features are completely independet and optional. Last but not least one can choose between normal leather seats or alcantara ones but not both. In this simplified model of a car we have all three types of features modeled.\\\\
\textbf{Decision modeling}\\
In decision modeling the variability is described with decisions instead of features. A variable feature in feature modeling is equal to a decision and vice versa. Contrary to feature modeling, decision modeling is unable to describe the commonalities of systems.\\

Decision models can be represented in different ways, broadly used approaches are flat lists or tables of decisions which also includes their dependencies. In decision modeling hierarchy is a secondary aspect, because there are no uniform rules to describe hierarchy. \cite{b6}\\

Same as feature modeling, decision modeling has been expanded over time to enable the application coverage of DM to be almost the same as FM.\cite{b6}\\

\section{Variability patterns}
Variability can be introduced into a system via different mechanisms. These mechanisms strive to bind a given system to one out of many alternatives at different binding times. Binding times describe when exactly these mechanisms stop deffering the decision and make the choice for any of the variations, as illustrated in Figure 2.\cite{b2}

\begin{figure}[h!]
	\includegraphics[width=\columnwidth]{binding_times}
	\caption{Binding Times \cite{b2}}
\end{figure}


Further explanation of these binding times can be found in the subsequent paragraphs:\\
\begin{itemize}
	\item \textit{Product architecture derivation.} The architecture of the product already binds to a variation. This is the lowest binding time and will influence all subsequent steps.\\
	\item \textit{Compilation.} When the source code is compiled there exist several options to bind to a variation by adjusting constants, macros or compiler directives.\\
	\item \textit{Linking.} This option does not exist for any technology, but for many programming languages the linking process can be manually changed. For example by switching the DLL of a module.\\
	\item \textit{Startup} A simple option to bind variants to the system is by configuration files that influence the features a software system exhibits.\\
	\item \textit{Adaptation to runtime environment} This typically refers to plugins of a software, which can add variation to a system and can either be provided by the original developer or even third party vendors. \\
\end{itemize}
Any mechanism to bind to none, one or many different variants tend to fall into different categories presented by \cite{b2} and \cite{b3}, and also have parallels to the feature types presented in the previous section:\\
\begin{itemize}
	\item \textit{Variant Entity.} There exist several options but only one may be bound to at any given time.\\
	\item \textit{Optional Entity.} As the name suggests, an optional entity may or may not be included in the system.\\
	\item \textit{Multiple Coexisting Entities.} Similar to the variant entity but with the exception that multiple variants can be used.\\
\end{itemize}
These categories tend to be the same for the different binding times, but of course vary greatly in their implementation. While an optional entity during compilation may only be influenced by a compiler flag, it might be a whole plugin from a third party vendor when adapting a given runtime environment. An in depth analysis of these mechanisms can be found in \cite{b2}.

\section{Discussion/Challenges}
The research field of variability had an increasing trend of published paper per year from 2000 until 2008. After that it stabilized between 25-30 new research papers per year from 2008 until 2011. One explanation of this rise in interest in the scientific community could be that the usage of variability was becoming more broadly used in dynamic systems. \cite{b4}\\

Another aspect is that feature modeling is in its core a simple concept. Even though its impact on the industry is enormous considering it is the most popular concept for variability modeling in software system as of now.\cite{b9} Due to the big amount of research having been done in this field we understand the subject reasonably well by now.\\

As mentioned in \cite{b4} the currently existing methods also have their limitations. 
\begin{itemize}
\item \textit{Guaranteed correctness and consistency}. Authors have to urge for verification and consistency checking.\\
\item \textit{Performance overheads} are difficult to model.\\
\item \textit{Runtime upgradability} and the process of switching features is sometimes necessary.\\
\item \textit{Lack of support for security needs} can be a factor whichs limits the use of feature modeling.\\
\item \textit{Poor user-friendliness} can be introduced by poor handling of variability, which decreases the usability of a system.\\
\end{itemize}

There are ways to decrease the negative impact of these aspects e.g. correctness and consistency can be checked by various methods such as modeling guidelines customized for specific needs, together with a reviewing process where changes to the model are checked by another person to ensure the quality of the mentioned parameters.\\

It should also be noted most of the studies in the area of FM are including some sort of tool to support the process. Only a few don't mention any form of software support.\\

\section{Conclussion}
In this document we have given a short introduction to the origin of variability, how to model it and what patterns exist as well as look over work related to these topics. \\

This information is vital for being able to manage variability, it does however, only glance over the different subjects and merely provides a theoretical basis. Practical use also depends on supporting software, which widely exists especially for the task of variability modelling, as well as practical knowledge in the field, which also aids in gaining an in depth understanding of managing variability.\\

For further information we refer the reader to the references, especially \cite{b2}, which gives a more in depth overview, and \cite{b6}, which compares different approaches to variability modelling.
\newpage

\begin{thebibliography}{00}
\bibitem{b1} S. Apel, D. Batory, C. Kästner and G. Saake, "Software Product Lines. In: Feature-Oriented Software Product Lines", Berlin Heidelberg, Springer (2013)
\bibitem{b2} J. van Gurp, J. Bosch and M. Svahnberg, "On the notion of variability in software product lines," Proceedings Working IEEE/IFIP Conference on Software Architecture", Amsterdam, Netherlands, 2001, pp. 45-54
\bibitem{b3} F. Bachmann, L. Bass, "Managing Variability in Software Architectures", Carnegie Mellon University (2001)
\bibitem{b4} M. Galster, D. Weyns, D. Tofan, M. Bartosz, P. Avgeriou, "Variability in Software Systems—A Systematic Literature Review", IEEE Transactions on Software Engineering (2014)
\bibitem{b5} T. Berger, J.-P. Steghöfer, T. Ziadi, J. Robin, and J. Martinez, "The state of adoption and the challenges of systematic variability management in industry", Empirical Software Engineering, vol. 25, pp. 1755-1797, 2020
\bibitem{b6}
K. Czarnecki, P. Grünbacher, R. Rabiser, K. Schmid., and A.
Wasowski, “Cool features and tough decisions: a comparison of
variability modeling approaches,” Proc. of the \textit{Sixth international
workshop on variability modeling of software-intensive systems
(VaMoS '12)}, ACM, Jan 2012, pp. 173-182.
\bibitem{b7}
Software Productivity Consortium Services Corporation,
Technical Report SPC-92019-CMC. \textit{Reuse-Driven Software
Processes Guidebook}, Version 02.00.03, 1993.
\bibitem{b8} K. C. Kang, S. Cohen, J. Hess, W. Novak, and S. Peterson,	 "Feature oriented domain analysis (FODA) feasibility study", Technical Report CMU/SEI-90-TR-21, Software Engineering Institute, Carnegie Mellon University, Pittburgh, PA, USA, 1990
\bibitem{b9} A. Metzger, and K. Pohl, "Software product line engineering and variability management: Achievements and challenges," \textit{Proc. of the Future of Software Engineering (FOSE 2014)}, ACM, 2014, pp. 70-84, doi:10.1145/2593882.2593888.
\bibitem{b10} M. Riebisch, K. Böllert, D. Streitferdt, and I. Philippow, "Extending Feature Diagrams with UML Multiplicities", \textit{6th World Conference on Integrated Design \& Process Technology (IDPT2002)}, vol. 23, 2002, pp. 1-7.
\end{thebibliography}

\end{document}
